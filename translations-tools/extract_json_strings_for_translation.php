<?php declare( strict_types=1 );

/**
 * Extract Translatable Strings from JSON Configuration
 * 
 * This script extracts all translatable strings from plugin.json and generates
 * a PHP file that can be scanned by POT file generators.
 * 
 * Usage: php extract_json_strings_for_translation.php
 * 
 * @requires PHP 7.4+
 */

class JsonStringExtractor {

	private string $pluginJsonPath;
	private string $outputPath;
	private array $translatableStrings = [];

	// Translatable keys using modern array syntax
	private const TRANSLATABLE_KEYS = [
		'title',
		'title_short',
		'summary',
		'description',
		'name',
		'tagline',
	];

	// Paths to exclude from translation
	private const EXCLUDE_PATHS = [
		'properties',
		'requirements',
		'paths',
		'includes',
		'menu.title', // Function call, not translatable string
	];

	public function __construct() {
		$this->pluginJsonPath = dirname( __DIR__ ) . '/plugin.json';
		$this->outputPath = dirname( __DIR__ ) . '/src/lib/src/translations-strings-auto.php';
	}

	public function run(): void {
		$this->validatePluginJsonExists();
		
		echo "Loading plugin.json...\n";
		$config = $this->loadAndParseJson();

		echo "Extracting translatable strings...\n";
		$this->extractStrings( $config );

		echo "Generating PHP translation file...\n";
		$this->generatePhpFile();

		$count = count( $this->translatableStrings );
		echo "✅ Generated: {$this->outputPath}\n";
		echo "✅ Found {$count} translatable strings.\n";
	}

	private function validatePluginJsonExists(): void {
		if ( !file_exists( $this->pluginJsonPath ) ) {
			throw new RuntimeException( "plugin.json not found at: {$this->pluginJsonPath}" );
		}
	}

	private function loadAndParseJson(): array {
		$jsonContent = file_get_contents( $this->pluginJsonPath );
		$config = json_decode( $jsonContent, true );

		if ( json_last_error() !== JSON_ERROR_NONE ) {
			throw new Exception( "Error parsing JSON: " . json_last_error_msg() );
		}

		return $config;
	}

	private function extractStrings( array $data, string $path = '' ): void {
		foreach ( $data as $key => $value ) {
			$currentPath = $path !== '' ? "{$path}.{$key}" : $key;

			if ( is_array( $value ) ) {
				$this->extractStrings( $value, $currentPath );
			} elseif ( is_string( $value ) ) {
				$this->processStringValue( $key, $value, $currentPath );
			}
		}
	}

	private function processStringValue( $key, string $value, string $path ): void {
		if ( $this->isTranslatable( $key, $path ) && $this->isValidTranslatableString( $value ) ) {
			$this->translatableStrings[ $value ] = $path;
		}
	}

	private function isTranslatable( $key, string $path ): bool {
		// Check if key is translatable
		if ( !is_string( $key ) || !in_array( $key, self::TRANSLATABLE_KEYS, true ) ) {
			return false;
		}

		// Check if path should be excluded
		foreach ( self::EXCLUDE_PATHS as $excludePath ) {
			if ( strpos( $path, $excludePath ) === 0 ) {
				return false;
			}
		}

		return true;
	}

	private function isValidTranslatableString( string $string ): bool {
		$string = trim( $string );
		
		// Skip empty strings, single characters, or just dots/dashes
		if ( $string === '' || $string === '.' || $string === '-' || strlen( $string ) <= 1 ) {
			return false;
		}

		// Skip function calls, URLs, and technical identifiers
		if ( strpos( $string, '(' ) !== false || 
			 strpos( $string, 'get' ) === 0 || 
			 strpos( $string, 'http' ) === 0 || 
			 strpos( $string, '/' ) !== false ) {
			return false;
		}

		// Skip common boolean/null values
		if ( in_array( $string, [ 'true', 'false', 'null', 'yes', 'no' ], true ) ) {
			return false;
		}

		// Skip technical IDs without spaces
		if ( ctype_alnum( str_replace( [ '_', '-' ], '', $string ) ) && strpos( $string, ' ' ) === false ) {
			return false;
		}

		return true;
	}
	private function generatePhpFile(): void {
		$timestamp = date( 'Y-m-d H:i:s' );
		$count = count( $this->translatableStrings );
		
		$php = "<?php declare( strict_types=1 );\n\n";
		$php .= "/**\n";
		$php .= " * AUTO-GENERATED Translation Declaration File\n";
		$php .= " * \n";
		$php .= " * This file is automatically generated from plugin.json\n";
		$php .= " * DO NOT EDIT MANUALLY - changes will be overwritten\n";
		$php .= " * \n";
		$php .= " * Generated on: {$timestamp}\n";
		$php .= " * Total strings: {$count}\n";
		$php .= " * \n";
		$php .= " * Usage: Run php extract_json_strings_for_translation.php to regenerate\n";
		$php .= " */\n\n";
		$php .= "if ( false ) { // This ensures the code is never executed but is parsed for translation\n\n";

		// Group and add strings
		$grouped = $this->groupStringsByContext();
		foreach ( $grouped as $section => $strings ) {
			$php .= "\t// {$section}\n";
			foreach ( $strings as $string => $context ) {
				$php .= $this->formatTranslationCall( $string, $context );
			}
			$php .= "\n";
		}

		$php .= "}\n";

		file_put_contents( $this->outputPath, $php );
	}

	private function formatTranslationCall( string $string, string $context ): string {
		// Check if string contains single quotes
		$hasSingleQuotes = strpos( $string, "'" ) !== false;
		
		if ( $hasSingleQuotes ) {
			// Use double quotes and escape any double quotes in the string
			$escaped = str_replace( '"', '\\"', $string );
			return "\t__( \"{$escaped}\", 'wp-simple-firewall' ); // {$context}\n";
		} else {
			// Use single quotes (no escaping needed for single quotes in single-quoted strings)
			return "\t__( '{$string}', 'wp-simple-firewall' ); // {$context}\n";
		}
	}

	private function groupStringsByContext(): array {
		$groups = [
			'Section Titles' => [],
			'Section Short Titles' => [],
			'Module Names & Taglines' => [],
			'Other Translatable Strings' => []
		];

		foreach ( $this->translatableStrings as $string => $context ) {
			if ( strpos( $context, 'sections' ) !== false && strpos( $context, 'title_short' ) !== false ) {
				$groups['Section Short Titles'][ $string ] = $context;
			} elseif ( strpos( $context, 'sections' ) !== false && strpos( $context, 'title' ) !== false ) {
				$groups['Section Titles'][ $string ] = $context;
			} elseif ( strpos( $context, 'modules' ) !== false ) {
				$groups['Module Names & Taglines'][ $string ] = $context;
			} else {
				$groups['Other Translatable Strings'][ $string ] = $context;
			}
		}

		// Remove empty groups
		return array_filter( $groups, function( $group ) {
			return !empty( $group );
		});
	}
}

// Run the extractor with error handling
try {
	( new JsonStringExtractor() )->run();
} catch ( Throwable $e ) {
	echo "❌ Error: {$e->getMessage()}\n";
	exit( 1 );
}
